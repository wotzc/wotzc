<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6新特性</title>
    <url>/2021/05/24/ES6%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>ECMAScript 6.0（以下简称ES6，ECMAScript 是一种由Ecma 国际(前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association)通过ECMA-262 标准化的脚本程序设计语言是JavaScript 语言的下一代标准，已经在2015 年6 月正式发布了，并且从ECMAScript 6 开始，开始采用年号来做版本。即ECMAScript 2015，就是ECMAScript6。它的目标，是使得JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。每年一个新版本。</p>
<h2 id="1-let和var的作用域"><a href="#1-let和var的作用域" class="headerlink" title="1.let和var的作用域"></a>1.let和var的作用域</h2><ul>
<li><p>var 声明的变量往往会越域,let 声明的变量有严格局部作用域</p>
</li>
<li><p>var 可以声明多次,let 只能声明一次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var m &#x3D; 1</span><br><span class="line">var m &#x3D; 2</span><br><span class="line">let n &#x3D; 3</span><br><span class="line">&#x2F;&#x2F; let n &#x3D; 4</span><br><span class="line">console.log(m) &#x2F;&#x2F; 2</span><br><span class="line">console.log(n) &#x2F;&#x2F; Identifier &#39;n&#39; has already been declared</span><br></pre></td></tr></table></figure>
</li>
<li><p>var 会变量提升,let 不存在变量提升</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(x); &#x2F;&#x2F; undefined</span><br><span class="line">var x &#x3D; 10;</span><br><span class="line">console.log(y); &#x2F;&#x2F;ReferenceError: y is not defined</span><br><span class="line">let y &#x3D; 20;</span><br></pre></td></tr></table></figure>
</li>
<li><p>const 声明常量（只读变量）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a &#x3D; 1;</span><br><span class="line">a &#x3D; 3; &#x2F;&#x2F;Uncaught TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2-解构表达式"><a href="#2-解构表达式" class="headerlink" title="2.解构表达式"></a>2.解构表达式</h2><ol>
<li><p><strong>数组解构</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const [x,y,z] &#x3D; arr;&#x2F;&#x2F; x，y，z 将与arr 中的每个位置对应来取值</span><br><span class="line">&#x2F;&#x2F; 然后打印</span><br><span class="line">console.log(x,y,z);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对象解构</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">name: &quot;jack&quot;,</span><br><span class="line">age: 21,</span><br><span class="line">language: [&#39;java&#39;, &#39;js&#39;, &#39;css&#39;]</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 解构表达式获取值，将person 里面每一个属性和左边对应赋值</span><br><span class="line">const &#123; name:abc, age, language &#125; &#x3D; person;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="3-字符串扩展"><a href="#3-字符串扩展" class="headerlink" title="3.字符串扩展"></a>3.字符串扩展</h2><ol>
<li><strong>几个新的API</strong></li>
</ol>
<h4 id="ES6-为字符串扩展了几个新的API："><a href="#ES6-为字符串扩展了几个新的API：" class="headerlink" title="ES6 为字符串扩展了几个新的API："></a>ES6 为字符串扩展了几个新的API：</h4><ul>
<li><p><code>includes()</code>：返回布尔值，表示是否找到了参数字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str &#x3D; &quot;hello.vue&quot;;</span><br><span class="line">console.log(str.includes(&quot;e&quot;));&#x2F;&#x2F;true</span><br><span class="line">console.log(str.includes(&quot;hello&quot;));&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>startsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的头部。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str &#x3D; &quot;hello.vue&quot;;</span><br><span class="line">console.log(str.startsWith(&quot;hello&quot;));&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<ul>
<li><code>endsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str &#x3D; &quot;hello.vue&quot;;</span><br><span class="line"></span><br><span class="line">console.log(str.endsWith(&quot;.vue&quot;));&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>几个新的API</strong></li>
</ol>
<p>模板字符串相当于加强版的字符串，用反引号`,除了作为普通字符串，还可以用来定义多行字符串，还可以在字符串中加入变量和表达式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、多行字符串</span><br><span class="line">let ss &#x3D; &#96;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">            &lt;span&gt;hello world&lt;span&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">         &#96;</span><br><span class="line">console.log(ss)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 2、字符串插入变量和表达式。变量名写在$&#123;&#125; 中，$&#123;&#125; 中可以放</span><br><span class="line">入JavaScript 表达式。</span><br><span class="line">let name &#x3D; &quot;张三&quot;;</span><br><span class="line">let age &#x3D; 18;</span><br><span class="line">let info &#x3D; &#96;我是$&#123;name&#125;，今年$&#123;age&#125;了&#96;;</span><br><span class="line">console.log(info)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 3、字符串中调用函数</span><br><span class="line">function fun() &#123;</span><br><span class="line">return &quot;这是一个函数&quot;</span><br><span class="line">&#125;</span><br><span class="line">let sss &#x3D; &#96;O(∩_∩)O 哈哈~，$&#123;fun()&#125;&#96;;</span><br><span class="line">console.log</span><br></pre></td></tr></table></figure>

<h2 id="4-函数优化"><a href="#4-函数优化" class="headerlink" title="4.函数优化"></a>4.函数优化</h2><ol>
<li><p><strong>函数参数默认值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;现在可以这么写：直接给参数写上默认值，没传就会自动使用默认值</span><br><span class="line">function add2(a , b &#x3D; 1) &#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 传一个参数</span><br><span class="line">console.log(add2(10));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不定参数</strong></p>
<p>不定参数用来表示不确定参数个数，形如，…变量名，由…加上一个具名参数标识符组成。<br>具名参数只能放在参数列表的最后，并且有且只有一个不定参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fun(...values) &#123;</span><br><span class="line">	console.log(values.length)</span><br><span class="line">&#125;</span><br><span class="line">fun(1, 2) &#x2F;&#x2F;2</span><br><span class="line">fun(1, 2, 3, 4) &#x2F;&#x2F;4</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>箭头函数</strong></p>
<p><strong>箭头函数this不能使用</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;以前声明一个方法</span><br><span class="line">&#x2F;&#x2F; var print &#x3D; function (obj) &#123;</span><br><span class="line">&#x2F;&#x2F; console.log(obj);</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br><span class="line">&#x2F;&#x2F; 可以简写为：</span><br><span class="line">var print &#x3D; obj &#x3D;&gt; console.log(obj);</span><br><span class="line">&#x2F;&#x2F; 测试调用</span><br><span class="line">print(100);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 两个参数的情况：</span><br><span class="line">var sum &#x3D; function (a, b) &#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 简写为：</span><br><span class="line">&#x2F;&#x2F;当只有一行语句，并且需要返回结果时，可以省略&#123;&#125; , 结果会自动返回。</span><br><span class="line">var sum2 &#x3D; (a, b) &#x3D;&gt; a + b;</span><br><span class="line">&#x2F;&#x2F;测试调用</span><br><span class="line">console.log(sum2(10, 10));&#x2F;&#x2F;20</span><br><span class="line">&#x2F;&#x2F; 代码不止一行，可以用&#96;&#123;&#125;&#96;括起来</span><br><span class="line">var sum3 &#x3D; (a, b) &#x3D;&gt; &#123;</span><br><span class="line">c &#x3D; a + b;</span><br><span class="line">return c;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;测试调用</span><br><span class="line">console.log(sum3(10, 20));&#x2F;&#x2F;30</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>箭头函数结合解构表达式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;需求，声明一个对象，hello 方法需要对象的个别属性</span><br><span class="line">&#x2F;&#x2F;以前的方式：</span><br><span class="line">const person &#x3D; &#123;</span><br><span class="line">    name: &quot;jack&quot;,</span><br><span class="line">    age: 21,</span><br><span class="line">    language: [&#39;java&#39;, &#39;js&#39;, &#39;css&#39;]</span><br><span class="line">&#125;</span><br><span class="line">function hello(person) &#123;</span><br><span class="line">	console.log(&quot;hello,&quot; + person.name)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;现在的方式</span><br><span class="line">var hello2 &#x3D; (&#123; name &#125;) &#x3D;&gt; &#123; console.log(&quot;hello,&quot; + name) &#125;;</span><br><span class="line">&#x2F;&#x2F;测试</span><br><span class="line">hello2(person);</span><br></pre></td></tr></table></figure>

<h2 id="5-对象优化"><a href="#5-对象优化" class="headerlink" title="5.对象优化"></a>5.对象优化</h2></li>
<li><p><strong>新增的API</strong></p>
<p>ES6 给Object 拓展了许多新的方法，如：</p>
<ul>
<li><p>keys(obj)：获取对象的所有key 形成的数组</p>
</li>
<li><p>values(obj)：获取对象的所有value 形成的数组</p>
</li>
<li><p>entries(obj)：获取对象的所有key 和value 形成的二维数组。格式：<code>[[k1,v1],[k2,v2],...]</code></p>
</li>
<li><p>assign(dest, …src) ：将多个src 对象的值拷贝到dest 中。（第一层为深拷贝，第二层为浅拷贝）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">name: &quot;jack&quot;,</span><br><span class="line">age: 21,</span><br><span class="line">language: [&#39;java&#39;, &#39;js&#39;, &#39;css&#39;]</span><br><span class="line">&#125;</span><br><span class="line">console.log(Object.keys(person));&#x2F;&#x2F;[&quot;name&quot;, &quot;age&quot;, &quot;language&quot;]</span><br><span class="line">console.log(Object.values(person));&#x2F;&#x2F;[&quot;jack&quot;, 21, Array(3)]</span><br><span class="line">console.log(Object.entries(person));&#x2F;&#x2F;[Array(2), Array(2), Array(2)]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const target &#x3D; &#123; a: 1 &#125;;</span><br><span class="line">const source1 &#x3D; &#123; b: 2 &#125;;</span><br><span class="line">const source2 &#x3D; &#123; c: 3 &#125;;</span><br><span class="line">&#x2F;&#x2F;Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。</span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">console.log(target)&#x2F;&#x2F;&#123;a: 1, b: 2, c: 3&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>声明对象简写</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const age &#x3D; 23</span><br><span class="line">const name &#x3D; &quot;张三&quot;</span><br><span class="line">&#x2F;&#x2F; 传统</span><br><span class="line">const person1 &#x3D; &#123; age: age, name: name &#125;</span><br><span class="line">console.log(person1)</span><br><span class="line">&#x2F;&#x2F; ES6：属性名和属性值变量名一样，可以省略</span><br><span class="line">const person2 &#x3D; &#123; age, name &#125;</span><br><span class="line">console.log(person2) &#x2F;&#x2F;&#123;age: 23, name: &quot;张三&quot;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对象的函数属性简写</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let person &#x3D; &#123;</span><br><span class="line">name: &quot;jack&quot;,</span><br><span class="line">&#x2F;&#x2F; 以前：</span><br><span class="line">eat: function (food) &#123;</span><br><span class="line">console.log(this.name + &quot;在吃&quot; + food);</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F; 箭头函数版：这里拿不到this</span><br><span class="line">eat2: food &#x3D;&gt; console.log(person.name + &quot;在吃&quot; + food),</span><br><span class="line">&#x2F;&#x2F; 简写版：</span><br><span class="line">eat3(food) &#123;</span><br><span class="line">console.log(this.name + &quot;在吃&quot; + food);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">person.eat(&quot;apple&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对象拓展运算符</strong></p>
<p>拓展运算符（…）用于取出参数对象所有可遍历属性然后拷贝到当前对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、拷贝对象（深拷贝）</span><br><span class="line">let person1 &#x3D; &#123; name: &quot;Amy&quot;, age: 15 &#125;</span><br><span class="line">let someone &#x3D; &#123; ...person1 &#125;</span><br><span class="line">console.log(someone) &#x2F;&#x2F;&#123;name: &quot;Amy&quot;, age: 15&#125;</span><br><span class="line">&#x2F;&#x2F; 2、合并对象</span><br><span class="line">let age &#x3D; &#123; age: 15 &#125;</span><br><span class="line">let name &#x3D; &#123; name: &quot;Amy&quot; &#125;</span><br><span class="line">let person2 &#x3D; &#123; ...age, ...name &#125; &#x2F;&#x2F;如果两个对象的字段名重复，后面对象字</span><br><span class="line">段值会覆盖前面对象的字段值</span><br><span class="line">console.log(person2) &#x2F;&#x2F;&#123;age: 15, name: &quot;Amy&quot;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="5-map-和reduce"><a href="#5-map-和reduce" class="headerlink" title="5.map 和reduce"></a>5.map 和reduce</h2><p>map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [&#39;1&#39;, &#39;20&#39;, &#39;-5&#39;, &#39;3&#39;];</span><br><span class="line">console.log(arr)</span><br><span class="line">arr &#x3D; arr.map(s &#x3D;&gt; parseInt(s));</span><br><span class="line">console.log(arr)</span><br></pre></td></tr></table></figure>

<p>语法：<br>arr.reduce(callback,[initialValue])<br>reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元<br>素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调<br>用reduce 的数组。<br>callback （执行数组中每个值的函数，包含四个参数）<br>1、previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））<br>2、currentValue （数组中当前被处理的元素）<br>3、index （当前元素在数组中的索引）<br>4、array （调用reduce 的数组）<br>initialValue （作为第一次调用callback 的第一个参数。）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [1,20,-5,3];</span><br><span class="line">&#x2F;&#x2F;没有初始值：</span><br><span class="line">console.log(arr.reduce((a,b)&#x3D;&gt;a+b));&#x2F;&#x2F;19</span><br><span class="line">console.log(arr.reduce((a,b)&#x3D;&gt;a*b));&#x2F;&#x2F;-300</span><br><span class="line">&#x2F;&#x2F;指定初始值：</span><br><span class="line">console.log(arr.reduce((a,b)&#x3D;&gt;a+b,1));&#x2F;&#x2F;20</span><br><span class="line">console.log(arr.reduce((a,b)&#x3D;&gt;a*b,0));&#x2F;&#x2F;-0</span><br></pre></td></tr></table></figure>

<h2 id="6-Promise"><a href="#6-Promise" class="headerlink" title="6.Promise"></a>6.Promise</h2><p>在JavaScript 的世界中，所有代码都是单线程执行的。由于这个“缺陷”，导致JavaScript 的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现。一旦有一连串的ajax 请求a,b,c,d… 后面的请求依赖前面的请求结果，就需要层层嵌套。这种缩进和层层嵌套的方式，非常容易造成上下文代码混乱，我们不得不非常小心翼翼处理内层函数与外层函数的数据，一旦内层函数使用了上层函数的变量，这种混乱程度就会加剧……总之，这种<code>层叠上下文</code>的层层嵌套式，着实增加了神经的紧张程度。</p>
<p>通常在企业开发中，会把promise 封装成通用方法，如下：封装了一个通用的get 请求方法；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let get &#x3D; function (url, data) &#123; &#x2F;&#x2F; 实际开发中会单独放到common.js 中</span><br><span class="line">	return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">		$.ajax(&#123;</span><br><span class="line">			url: url,</span><br><span class="line">			type: &quot;GET&quot;,</span><br><span class="line">			data: data,</span><br><span class="line">			success(result) &#123;</span><br><span class="line">				resolve(result);</span><br><span class="line">			&#125;,</span><br><span class="line">			error(error) &#123;</span><br><span class="line">				reject(error);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 使用封装的get 方法，实现查询分数</span><br><span class="line">get(&quot;mock&#x2F;user.json&quot;).then((result) &#x3D;&gt; &#123;</span><br><span class="line">console.log(&quot;查询用户：&quot;, result);</span><br><span class="line">return get(&#96;mock&#x2F;user_corse_$&#123;result.id&#125;.json&#96;);</span><br><span class="line">&#125;).then((result) &#x3D;&gt; &#123;</span><br><span class="line">console.log(&quot;查询到课程：&quot;, result);</span><br><span class="line">return get(&#96;mock&#x2F;corse_score_$&#123;result.id&#125;.json&#96;)</span><br><span class="line">&#125;).then((result) &#x3D;&gt; &#123;</span><br><span class="line">console.log(&quot;查询到分数：&quot;, result);</span><br><span class="line">&#125;).catch(() &#x3D;&gt; &#123;</span><br><span class="line">console.log(&quot;出现异常了：&quot; + error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>通过比较，我们知道了Promise 的扁平化设计理念，也领略了这种<code>上层设计</code>带来的好处。我们的项目中会使用到这种异步处理的方式；</p>
<h2 id="7-模块化"><a href="#7-模块化" class="headerlink" title="7.模块化"></a>7.模块化</h2><p>模块化就是把代码进行拆分，方便重复利用。类似java 中的导包：要使用一个包，必须先导包。而JS 中没有包的概念，换来的是模块。<br>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<br>. <code>export</code>命令用于规定模块的对外接口。<br>. <code>import</code>命令用于导入其他模块提供的功能。</p>
<ol>
<li><p><strong>export</strong></p>
<p>比如我定义一个js 文件:hello.js，里面有一个对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const util &#x3D; &#123;</span><br><span class="line">    sum(a,b)&#123;</span><br><span class="line">    	return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我可以使用export 将这个对象导出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const util &#x3D; &#123;</span><br><span class="line">    sum(a,b)&#123;</span><br><span class="line">    	return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export &#123;util&#125;;</span><br></pre></td></tr></table></figure>

<p><code>export</code>不仅可以导出对象，一切JS 变量都可以导出。比如：基本类型变量、函数、数组、对象。<br>当要导出多个值时，还可以简写。比如我有一个文件：user.js：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &quot;jack&quot;</span><br><span class="line">var age &#x3D; 21</span><br><span class="line">export &#123;name,age&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>import</strong></p>
<p>使用<code>export</code>命令定义了模块的对外接口以后，其他JS 文件就可以通过<code>import</code>命令加载这个模块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import util from &#39;hello.js&#39;</span><br><span class="line">&#x2F;&#x2F; 调用util 中的属性</span><br><span class="line">util.sum(1,2)</span><br></pre></td></tr></table></figure>

<p>要批量导入前面导出的name 和age：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;name, age&#125; from &#39;user.js&#39;</span><br><span class="line">console.log(name + &quot; , 今年&quot;+ age +&quot;岁了&quot;)</span><br></pre></td></tr></table></figure>

<p>但是上面的代码暂时无法测试，因为浏览器目前还不支持ES6 的导入和导出功能。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo多设备管理</title>
    <url>/2020/11/16/hexo%E5%A4%9A%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="如何在不同设备快速、高效的管理自己的博客？"><a href="#如何在不同设备快速、高效的管理自己的博客？" class="headerlink" title="如何在不同设备快速、高效的管理自己的博客？"></a>如何在不同设备快速、高效的管理自己的博客？</h3><p>这里采用分支的方法，在一个Github Pages项目上，实现不同终端的管理工作。</p>
<p>实现原理：<br>在项目上创建一个分支，暂定为hexo分支。<br>master分支和hexo分支互不干扰：</p>
<ul>
<li>master分支存放hexo编译后的文件，是用来生成网页的</li>
<li>Hexo分支源文件</li>
</ul>
<p>机制是这样的，由于<code>hexo d</code>上传部署到github的其实是hexo编译后的文件，是用来生成网页的，不包含源文件。也就是上传的是在本地目录里自动生成的<code>.deploy_git</code>里面。其他文件 ，包括我们写在source 里面的，和配置文件，主题文件，都没有上传到github。所以可以利用git的分支管理，将源文件上传到github的另一个分支即可。</p>
<h3 id="上传分支"><a href="#上传分支" class="headerlink" title="上传分支"></a>上传分支</h3><p>首先，先在github上新建一个hexo分支，然后在这个仓库的settings中，选择默认分支为hexo分支（这样每次同步的时候就不用指定分支，比较方便）。</p>
<p>然后在本地的任意目录下，打开git bash：</p>
<blockquote>
<p>​    git clone <a href="mailto:&#x67;&#x69;&#x74;&#64;&#x67;&#x69;&#x74;&#x68;&#x75;&#98;&#x2e;&#x63;&#x6f;&#109;">&#x67;&#x69;&#x74;&#64;&#x67;&#x69;&#x74;&#x68;&#x75;&#98;&#x2e;&#x63;&#x6f;&#109;</a>:wotzc/wotzc.github.io.git    </p>
</blockquote>
<p>将其克隆到本地，因为默认分支已经设成了hexo，所以clone时只clone了hexo。</p>
<p>接下来在克隆到本地的<code>wotzc.github.io</code>中，把除了.git 文件夹外的所有文件都删掉，把之前我们写的博客源文件全部复制过来，除了<code>.deploy_git</code>。这里应该说一句，复制过来的源文件应该有一个<code>.gitignore</code>，用来忽略一些不需要的文件，如果没有的话，自己新建一个，在里面写上如下，表示这些类型文件不需要git：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure>

<p>如果你之前克隆过theme中的主题文件，那么应该把将博客目录下 themes 文件夹下每个主题文件夹里面的 .git .gitignore 删掉。，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了。</p>
<p>cd 到博客目录，git add -A ，git commit -m “–”，git push origin hexo，将博客目录下所有文件更新到 hexo 分支。如果上一步没有删掉 .git .gitignore，主题文件夹下内容将传不上去。至此原电脑上的操作结束。</p>
<h3 id="新设备上的操作"><a href="#新设备上的操作" class="headerlink" title="新设备上的操作"></a>新设备上的操作</h3><p>在新电脑上操作，先把新电脑上环境安装好一样的，跟之前的环境搭建一样。</p>
<ul>
<li>安装git</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>

<ul>
<li>设置git全局邮箱和用户名</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yourgithubname&quot;</span><br><span class="line">git config --global user.email &quot;yourgithubemail&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置ssh key</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail&quot;</span><br><span class="line">#生成后填到github和coding上（有coding平台的话）</span><br><span class="line">#验证是否成功</span><br><span class="line">ssh -T git@github.com</span><br><span class="line">ssh -T git@git.coding.net #(有coding平台的话)</span><br></pre></td></tr></table></figure>

<ul>
<li>安装nodejs</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure>

<ul>
<li>安装hexo</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p>但是已经不需要初始化了，直接在任意文件夹下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:wotzc/wotzc.github.io.git</span><br></pre></td></tr></table></figure>

<p>然后进入克隆到的文件夹：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cd xxx.github.io</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>生成，部署：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>然后就可以开始写你的新博客了</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">hexo new newpage</span><br></pre></td></tr></table></figure>

<h3 id="日常更新"><a href="#日常更新" class="headerlink" title="日常更新"></a>日常更新</h3><p>以后无论在哪台电脑上，更新以及提交博客，依次执行，git pull，git add -A ，git commit -m “–”，git push origin hexo，hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 即可。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>初识Maven</title>
    <url>/2021/04/15/%E5%88%9D%E8%AF%86Maven/</url>
    <content><![CDATA[<h2 id="1-什么是Maven"><a href="#1-什么是Maven" class="headerlink" title="1.什么是Maven?"></a>1.什么是Maven?</h2><p>Maven 是 Apache 软件基金会组织维护的一款自动化构建工具 ，专注服务于ava平台的项目构建和依赖管理 。Maven 这个单词的本意是：专家 ，内行。</p>
<h3 id="1-1-依赖管理"><a href="#1-1-依赖管理" class="headerlink" title="1.1 依赖管理"></a>1.1 依赖管理</h3><p>​    在今天的 JavaEE 开发领域，有大量的第三方框架和工具可以供我们使用。要使用这些 jar 包最简单的方法就是复制粘贴到 WEB-INF/lib 目录下。但是这会导致每次创建一个新的工程就需要将 jar 包重复复制到 lib 目录下，从而造成工作区中存在大量重复的文件，让我们的工程显得很臃肿。</p>
<p>​    而使用 Maven 后每个 jar 包本身只在本地仓库中保存一份，需要 jar 包的工程只需要以坐标的方式简单的引用一下就可以了。不仅极大的节约了存储空间，让项目更轻巧，更避免了重复文件太多而造成的混乱。</p>
<p>​    jar 包往往不是孤立存在的，很多 jar 包都需要在其他 jar 包的支持下才能够正常工作，我们称之为jar 包之间的依赖关系。最典型的例子是：commons-fileupload-1.3.jar 依赖于 commons-io-2.0.1.jar，如果没有 IO 包，FileUpload 包就不能正常工作。</p>
<p>​    那么问题来了，你知道你所使用的所有 jar 包的依赖关系吗？当你拿到一个新的从未使用过的 jar包，你如何得知他需要哪些 jar 包的支持呢？如果不了解这个情况，导入的 jar 包不够，那么现有的程序将不能正常工作。再进一步，当你的项目中需要用到上百个 jar 包时，你还会人为的，手工的逐一确认它们依赖的其他 jar 包吗？这简直是不可想象的。</p>
<p>​    而引入 Maven 后，Maven 就可以替我们自动的将当前 jar 包所依赖的其他所有 jar 包全部导入进来，无需人工参与，节约了我们大量的时间和精力。</p>
<p>​    此外,JavaEE 开发中需要使用到的 jar 包种类繁多，几乎每个 jar 包在其本身的官网上的获取方式都不尽相同。为了查找一个 jar 包找遍互联网，身心俱疲，没有经历过的人或许体会不到这种折磨。不仅如此，费劲心血找的 jar 包里有的时候并没有你需要的那个类，又或者又同名的类没有你要的方法——以不规范的方式获取的 jar 包也往往是不规范的。</p>
<p>​    使用 Maven 我们可以享受到一个完全统一规范的 jar 包管理体系。你只需要在你的项目中以坐标的方式依赖一个 jar 包，Maven 就会自动从中央仓库进行下载，并同时下载这个 jar 包所依赖的其他 jar 包。</p>
<h3 id="1-2-项目构建"><a href="#1-2-项目构建" class="headerlink" title="1.2 项目构建"></a>1.2 项目构建</h3><p>​    在实际项目中整合第三方框架，Web 工程中除了 Java 程序和 JSP 页面、图片等静态资源之外，还包括第三方框架的 jar 包以及各种各样的配置文件。所有这些资源都必须按照正确的目录结构部署到服务器上，项目才可以运行。</p>
<p>​    所以综上所述：构建就是以我们编写的 Java 代码、框架配置文件、国际化等其他资源文件、JSP 页面和图片等静态资源作为“原材料”，去“生产”出一个可以运行的项目的过程。</p>
<p>​    那么项目构建的全过程中都包含哪些环节呢？</p>
<p>​    ①<strong>清理</strong>：删除以前的编译结果，为重新编译做好准备。</p>
<p>​    ②<strong>编译</strong>：将 Java 源程序编译为字节码文件。</p>
<p>​    ③<strong>测试</strong>：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。</p>
<p>​    ④<strong>报告</strong>：在每一次测试后以标准的格式记录和展示测试结果。</p>
<p>​    ⑤<strong>打包</strong>：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java 工程对应 jar 包，Web工程对应 war 包。</p>
<p>​    ⑥<strong>安装</strong>：在 Maven 环境下特指将打包的结果——jar 包或 war 包安装到本地仓库中。</p>
<p>​    ⑦<strong>部署</strong>：将打包的结果部署到远程仓库或将 war 包部署到服务器上运行。</p>
<p>​    大家看看，项目的构建可绝不仅仅是编译软件这件事情。除了写代码，在项目层面做的大部分工作，都包含在构建的过程中。有了Maven，构建中的这些过程都能够进行良好的定义（模式、固化、共识，记住这些关键词哪），而且Maven能够帮我们串起来形成一个自动构建过程，这样比我们手动执行要高效得多。</p>
<h2 id="2-Maven核心概念"><a href="#2-Maven核心概念" class="headerlink" title="2.Maven核心概念"></a>2.Maven核心概念</h2><p>​    Maven 能够实现自动化构建是和它的内部原理分不开的，这里我们从 Maven 的九个核心概念入手，</p>
<p>​    看看 Maven 是如何实现自动化构建的</p>
<p>​        ①POM</p>
<p>​        ②约定的目录结构</p>
<p>​        ③坐标</p>
<p>​        ④依赖管理</p>
<p>​        ⑤仓库管理</p>
<p>​        ⑥生命周期</p>
<p>​        ⑦插件和目标</p>
<p>​        ⑧继承</p>
<p>​        ⑨聚合</p>
<h3 id="2-1-Maven-的核心程序"><a href="#2-1-Maven-的核心程序" class="headerlink" title="2.1 Maven 的核心程序"></a>2.1 Maven 的核心程序</h3><p>​    Maven 的<strong>核心程序</strong>中仅仅定义了抽象的生命周期，而具体的操作则是由 Maven 的<strong>插件</strong>来完成的。可是Maven 的插件并不包含在 Maven 的核心程序中，在首次使用时需要联网下载。</p>
<p>​    下载得到的插件会被保存到本地仓库中。本地仓库默认的位置是：~.m2\repository。</p>
<h3 id="2-2-核心概念"><a href="#2-2-核心概念" class="headerlink" title="2.2 核心概念"></a>2.2 核心概念</h3><h4 id="2-2-1-POM"><a href="#2-2-1-POM" class="headerlink" title="2.2.1 POM"></a>2.2.1 POM</h4><p>​    Project Object Model：项目对象模型。将 Java <strong>工程</strong>的相关信息封装为<strong>对象</strong>作为便于操作和管理的<strong>模型</strong>。Maven 工程的核心配置。可以说学习 Maven 就是学习 pom.xml 文件中的配置。</p>
<h4 id="2-2-2-坐标"><a href="#2-2-2-坐标" class="headerlink" title="2.2.2 坐标"></a>2.2.2 坐标</h4><p>​    使用如下三个向量在 Maven 的仓库中唯一的确定一个 Maven 工程。</p>
<p>​    [1]groupid：公司或组织的域名倒序+当前项目名称</p>
<p>​    [2]artifactId：当前项目的模块名称</p>
<p>​    [3]version：当前模块的版本</p>
<p>​    使用如下三个向量在 Maven 的仓库中唯一的确定一个 Maven 工程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;groupId&gt;com.atguigu.maven&lt;&#x2F;groupId&gt;</span><br><span class="line"></span><br><span class="line">&lt;artifactId&gt;Hello&lt;&#x2F;artifactId&gt;</span><br><span class="line"></span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br></pre></td></tr></table></figure>

<p>如何通过坐标到仓库中查找 jar 包？</p>
<p>​    [1]将 gav 三个向量连起来</p>
<p>​    com.atguigu.maven+Hello+0.0.1-SNAPSHOT</p>
<p>​    [2]以连起来的字符串作为目录结构到仓库中查找</p>
<p>​    com/atguigu/maven/Hello/0.0.1-SNAPSHOT/Hello-0.0.1-SNAPSHOT.jar</p>
<p>​    ※<strong>注意</strong>：我们自己的 Maven 工程必须执行安装操作才会进入仓库。安装的命令是：mvn install</p>
<h4 id="2-2-3-依赖"><a href="#2-2-3-依赖" class="headerlink" title="2.2.3 依赖"></a>2.2.3 依赖</h4><p>​    Maven 中最关键的部分，我们使用 Maven 最主要的就是使用它的依赖管理功能。要理解和掌握 Maven的依赖管理，我们只需要解决一下几个问题：</p>
<p>​    ①依赖的目的是什么</p>
<p>​    当 A jar 包用到了 B jar 包中的某些类时，A 就对 B 产生了依赖，这是概念上的描述。那么如何在项目中以依赖的方式引入一个我们需要的 jar 包呢？</p>
<p>​    答案非常简单，就是使用 dependency 标签指定被依赖 jar 包的坐标就可以了。</p>
<pre><code>&lt;dependency&gt;
        &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;
        &lt;artifactId&gt;Hello&lt;/artifactId&gt;
        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
        &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
<h5 id="2-2-3-1-依赖的范围"><a href="#2-2-3-1-依赖的范围" class="headerlink" title="2.2.3.1 依赖的范围"></a>2.2.3.1 依赖的范围</h5><p>大家注意到上面的依赖信息中除 了目标jar包的坐标还有一个scope设置,这是依赖的范围.依赖的范围有几个可选值,常用的是:compile  test provide三个    </p>
<p>​    compile: 编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的maven依赖，对于编译 测试 运行三种的classpath都有效。</p>
<p>​    test：测试依赖范围。使用此依赖范围的Maven依赖，只对于测试的classpath有效，在编译主代码或者运行主代码的时候都无法依赖此类依赖。典型的例子是jUnit,它只有在编译测试代码及运行测试代码的时候才有效。</p>
<p>​    provided:以提供依赖范围。使用此依赖范围的maven依赖，对于编译和测试classpath有效，但在运行时无效。典型的例子是servlet-api，编译和测试项目的时候需要该依赖，但在运行的时候，由于容器已经提供，就不需要maven重复地引入一遍。打包的时候可以不用包进去，别的设施会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。相当于compile，但是打包阶段做了exclude操作</p>
<h5 id="2-2-3-2-依赖的排除"><a href="#2-2-3-2-依赖的排除" class="headerlink" title="2.2.3.2 依赖的排除"></a>2.2.3.2 依赖的排除</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;executions&gt;  </span><br><span class="line">	&lt;execution&gt;  </span><br><span class="line">		&lt;groupId&gt; &lt;&#x2F;groupId&gt; </span><br><span class="line">		&lt;artifactId&gt;&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;&#x2F;execution&gt;  </span><br><span class="line">&lt;&#x2F;executions&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-3-3-统一管理所依赖jar包的版本"><a href="#2-2-3-3-统一管理所依赖jar包的版本" class="headerlink" title="2.2.3.3 统一管理所依赖jar包的版本"></a>2.2.3.3 统一管理所依赖jar包的版本</h5><p>[1] 统一声明版本号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt; </span><br><span class="line">	&lt;atguigu.spring.version&gt;4.1.1.RELEASE&lt;&#x2F;atguigu.spring.version&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure>

<p>其中 atguigu.spring.version 部分是自定义标签。</p>
<p> [2]引用前面声明的版本号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">  	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; </span><br><span class="line">		&lt;artifactId&gt;spring-core&lt;&#x2F;artifactId&gt; </span><br><span class="line">		&lt;version&gt;$&#123;atguigu.spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;&#x2F;dependency&gt; </span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-仓库"><a href="#3-仓库" class="headerlink" title="3.仓库"></a>3.仓库</h2><h3 id="3-1-分类"><a href="#3-1-分类" class="headerlink" title="3.1 分类"></a>3.1 分类</h3><p>[1]本地仓库:为当前本机电脑上的所有 Maven 工程服务。 </p>
<p>[2]远程仓库<br>    (1)私服:架设在当前局域网环境下，为当前局域网范围内的所有 Maven 工程服务。</p>
<p><img src="https://myblob-pics.oss-cn-hangzhou.aliyuncs.com/mavensifu.png" alt="Maven服务器"></p>
<p>(2)中央仓库：架设在 Internet 上，为全世界所有 Maven 工程服务。</p>
<p>(3)中央仓库的镜像：架设在各个大洲，为中央仓库分担流量。减轻中央仓库的压力，同时更快的响应用户请求。</p>
<h2 id="4-生命周期"><a href="#4-生命周期" class="headerlink" title="4.生命周期"></a>4.生命周期</h2><h3 id="4-1-什么是-Maven-的生命周期？"><a href="#4-1-什么是-Maven-的生命周期？" class="headerlink" title="4.1 什么是 Maven 的生命周期？"></a>4.1 什么是 Maven 的生命周期？</h3><p>Maven 生命周期定义了各个构建环节的执行顺序，有了这个清单，Maven 就可以自动化的执行构建命令了。</p>
<p>Maven 有三套相互独立的生命周期，分别是：</p>
<p>①Clean Lifecycle 在进行真正的构建之前进行一些清理工作。</p>
<p>②Default Lifecycle 构建的核心部分，编译，测试，打包，安装，部署等等。</p>
<p>③Site Lifecycle 生成项目报告，站点，发布站点。它们是相互独立的，你可以仅仅调用 clean 来清理工作目录，仅仅调用 site 来生成站点。当然你也可以直接运行 mvn clean install site 运行所有这三套生命周期。</p>
<p>每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行 mvn clean，这个 clean 是 Clean 生命周期的一个阶段。有 Clean 生命周期，也有 clean 阶段。</p>
<h3 id="4-2-Clean-生命周期"><a href="#4-2-Clean-生命周期" class="headerlink" title="4.2 Clean 生命周期"></a>4.2 Clean 生命周期</h3><p>Clean 生命周期一共包含了三个阶段：</p>
<p>①pre-clean 执行一些需要在 clean 之前完成的工作</p>
<p>②clean 移除所有上一次构建生成的文件</p>
<p>③post-clean 执行一些需要在 clean 之后立刻完成的工作</p>
<h3 id="4-3-Site-生命周期"><a href="#4-3-Site-生命周期" class="headerlink" title="4.3 Site 生命周期"></a>4.3 Site 生命周期</h3><p>①pre-site 执行一些需要在生成站点文档之前完成的工作</p>
<p>②site 生成项目的站点文档</p>
<p>③post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</p>
<p>④site-deploy 将生成的站点文档部署到特定的服务器上</p>
<p>这里经常用到的是 site 阶段和 site-deploy 阶段，用以生成和发布 Maven 站点，这可是 Maven 相当强大的功能，Manager 比较喜欢，文档及统计数据自动生成，很好看。</p>
<h3 id="4-4-Default-生命周期"><a href="#4-4-Default-生命周期" class="headerlink" title="4.4 Default 生命周期"></a>4.4 Default 生命周期</h3><p>Default 生命周期是 Maven 生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里，只解释一些比较重要和常用的阶段：</p>
<p>validate</p>
<p>generate-sources</p>
<p>process-sources</p>
<p>generate-resources</p>
<p>process-resources 复制并处理资源文件，至目标目录，准备打包。</p>
<p>compile 编译项目的源代码。</p>
<p>process-classes</p>
<p>generate-test-sources</p>
<p>process-test-sources</p>
<p>generate-test-resources</p>
<p>process-test-resources 复制并处理资源文件，至目标测试目录。</p>
<p>test-compile 编译测试源代码。</p>
<p>process-test-classes</p>
<p>test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。</p>
<p>prepare-package</p>
<p>package 接受编译好的代码，打包成可发布的格式，如 JAR。</p>
<p>pre-integration-test</p>
<p>integration-test</p>
<p>post-integration-test</p>
<p>verify</p>
<p>install 将包安装至本地仓库，以让其它项目依赖。</p>
<p>deploy 将最终的包复制到远程的仓库，以让其它开发人员与项目共享或部署到服务器上运行。</p>
<h3 id="4-5-生命周期与自动化构建"><a href="#4-5-生命周期与自动化构建" class="headerlink" title="4.5 生命周期与自动化构建"></a>4.5 生命周期与自动化构建</h3><p><strong>运行任何一个阶段的时候，它前面的所有阶段都会被运行</strong>，例如我们运行 mvn install 的时候，代码会被编译，测试，打包。这就是 Maven 为什么能够自动执行构建过程的各个环节的原因。此外，Maven 的插件机制是完全依赖 Maven 的生命周期的，因此理解生命周期至关重要。</p>
<h2 id="5-插件和目标"><a href="#5-插件和目标" class="headerlink" title="5.插件和目标"></a>5.插件和目标</h2><p>● Maven 的核心仅仅定义了抽象的生命周期，具体的任务都是交由插件完成的。</p>
<p>● 每个插件都能实现多个功能，每个功能就是一个插件目标。</p>
<p>● Maven 的生命周期与插件目标相互绑定，以完成某个具体的构建任务。</p>
<p>例如：compile 就是插件 maven-compiler-plugin 的一个目标；pre-clean 是插件 maven-clean-plugin 的一个目标。</p>
<h2 id="6-继承"><a href="#6-继承" class="headerlink" title="6.继承"></a>6.继承</h2><p>Maven继承的特性则能够帮助抽取各模块之前相同依赖和插件配置，在简化POM的同时还能存在各个模块配置的一致性。对于规范项目开发，避免可能存在的版本不一致的问题，有良好的预防作用。</p>
<h2 id="7-聚合"><a href="#7-聚合" class="headerlink" title="7.聚合"></a>7.聚合</h2><h3 id="7-1-为什么要使用聚合？"><a href="#7-1-为什么要使用聚合？" class="headerlink" title="7.1 为什么要使用聚合？"></a>7.1 为什么要使用聚合？</h3><p>将多个工程拆分为模块后，需要手动逐个安装到仓库后依赖才能够生效。修改源码后也需要逐个手动进行 clean 操作。而使用了聚合之后就可以批量进行 Maven 工程的安装、清理工作。</p>
<h3 id="7-2-如何配置聚合"><a href="#7-2-如何配置聚合" class="headerlink" title="7.2 如何配置聚合?"></a>7.2 如何配置聚合?</h3><p>在总的聚合工程中使用 modules/module 标签组合，指定模块工程的相对路径即可 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;modules&gt; </span><br><span class="line">	&lt;module&gt;..&#x2F;Hello&lt;&#x2F;module&gt; </span><br><span class="line">	&lt;module&gt;..&#x2F;HelloFriend&lt;&#x2F;module&gt; </span><br><span class="line">	&lt;module&gt;..&#x2F;MakeFriends&lt;&#x2F;module&gt;</span><br><span class="line">&lt;&#x2F;modules&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Maven</tag>
        <tag>Java</tag>
        <tag>依赖管理</tag>
      </tags>
  </entry>
</search>
